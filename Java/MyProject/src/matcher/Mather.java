package matcher;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * group是针对()来说的，group(0)就是指的整个串，group(1)指的是第一个括号里的东西，group(2)指的是第二个括号里的东西
 */
public class Mather {
	public static void main(String[] args) {
		//matherMethod();
		
		matherChar();
	}

	/**
	 * 一、元字符：有特定含义的字符
	 * .  : 匹配除换行符以外的任意字符
	 * \w : 匹配字母或数字或下划线
	 * \s : 匹配任意的空白符
	 * \d : 匹配数字
	 * \b : 匹配单词的开始或者结束
	 * ^  : 匹配字符串的开始（在集合字符里[^a]标识非【不匹配】的意思）
	 * $  : 匹配字符串的结束
	 * [\\u4E00-\\u9FA5]:匹配汉字
	 * 
	 * 二、反义字符：多用于查找除某个字符以外的其他任意字符均可以的情况
	 * \W : 匹配任意不是字母、数字或者下划线的字符
	 * \S : 匹配任意不是空白的字符
	 * \D : 匹配任意非数字的字符
	 * \B : 匹配不是单词开头或结束的位置
	 * [^x]:匹配除了x以外的任意字符
	 * [^aeiou]:匹配除了aeiou这几个字母以外的任意字符
	 * [^\\u4E00-\\u9FA5]:匹配汉字除外的字符
	 * 
	 * 三、限定字符：多用于重复匹配次数
	 * *  : 重复零次或者多次
	 * +  : 重复一次或者更多次
	 * ?  : 重复零次或者一次
	 * {n}: 重复n次
	 * {n,}:重复n次或更多次
	 * {n,m}:重复n次到m次
	 * 
	 * 四、转义字符：在开发的过程中，可能使用元字符，这个时候就需要进行字符转义
	 * 元字符. * \需要转换为\. \* \\
	 * 
	 * 五、字符分枝
	 * 字符分枝多用于满足不同情况的选择，用"|"将不同的条件分割开来
	 * 
	 * 六、字符分组：用于将多个字符重复，主要通过使用小括号()进行分组
	 *   分类			代码/语法				说明
	 *   				 (exp)			匹配exp,并捕获文本到自动命名的组里
	 *   捕获		  (?<name>exp)		匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
	 *   				(?:exp)			匹配exp,并捕获匹配的文本，也不给此分组分配括号
	 *   
	 *  				(?=exp)			匹配exp前面的位置
	 * 零宽断言			(?<=exp)		匹配exp后面的位置
	 * 					(?!exp)			匹配后面跟不是exp的位置
	 * 					(?<!exp)		匹配前面不是exp的位置
	 * 
	 *   注释			(?#comment)		这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读
	 *   
	 * 七、懒惰匹配和贪婪匹配
	 * 贪婪匹配：正则表达式中包含重复的限定符时，通常的行为是尽可能多的字符
	 * 
	 * 懒惰匹配，有时候需要匹配尽可能少的字符
	 * 
	 * 例如：a.*b，他将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，他会匹配整个字符串aabab。但是我们此时可能
	 * 需要匹配的是ab这样的话就需要用到懒惰匹配了。懒惰匹配会匹配尽可能少的字符
	 * 常用的懒惰匹配限定符如下：
	 * 
	 *  	代码/语法					说明
	 * 		   *? 				重复任意次，但尽可能少重复
	 * 		   +? 				重复1次或者更多次，但尽可能少重复
	 *		   ??				重复0次或1次，但尽可能少重复
	 *		  {n,m}?			重复n到m次，但尽可能少重复
	 *		   {n,}?			重复n次以上，但尽可能少重复
	 */
	private static void matherChar() {
		String str = "";
		String cstr = "";
		//=========================================元字符=========================================
		//str = "11 ,2a , 1_ ,"; cstr = "\\d\\w\\s";//匹配第一个字符为数字，第二个字符为字母或者数字、或下划线或汉字，第三字符为空格的字符串
		//str = "123"; cstr = "^\\d\\d\\d$";//匹配三个全部都为数字的字符串
		//str = "12345678"; cstr = "^\\d{8}$";//匹配8位数字的qq号
		//str = "I Love Oliver and Olive"; cstr = "\\bOlive\\b";//结果是Olive，因为\b匹配的是单词的开始或者结束
		//str = "我是哥"; cstr = "^[\\u4E00-\\u9FA5]{2,4}$";//匹配2~4个中文字符
		
		//=========================================反义字符=========================================
		//str = "1_a我,+-"; cstr = "\\W";//匹配除字母、数字、下划线、汉字以外的字符。如 +,-
		//str = "学霸   是我   的   儿子"; cstr = "\\S";//匹配除了空格以外的任意字符
		//str = "abcdefghijk"; cstr = "[^aeiou]";//匹配除了aeiou这几个字母以外的任意字符
		//str = "我是哥IAMBROTHER"; cstr = "[^\\u4E00-\\u9FA5]";//查找字符串中的非汉字字符
		
		//=========================================限定字符=========================================
		//str = "(2,3,。。。)"; cstr = "\\d*";//匹配重复0次或多次的数字，可能为空
		//str = "1,23,234,2345"; cstr = "\\d+";//匹配重复一次或多次的数字
		//str = "(1,2,。。。)"; cstr = "\\d?";//匹配重复0次或着一次的数字，可能为空
		//str = "12345678"; cstr = "\\d{8}";//匹配重复8次数字
		//str = "1234,12345,124244"; cstr = "\\d{4,}";//匹配重复至少4次数字
		//str = "12345678,123456789,1234567890,12345678901"; cstr = "\\d{8,11}";//匹配重复8-11次的数字
		
		
		//=========================================转义字符=========================================
		//str = "1900894959@qq.com"; cstr = "\\d{8,}+@+qq+\\.+com";//在这里的.就需要加斜杠
		
		//=========================================分枝字符=========================================
		//str = "1523-13883438"; cstr = "\\d{3}-\\d{8}|\\d{4}-\\d{8}";//可以匹配两种不同长度区号的固定电话
		
		//=========================================字符分组=========================================
		//str = "1a2b3c"; cstr = "(\\d\\w){3}";//匹配数字+字母、数字、下划线，重复匹配3次
		/*
		 * 先把IP地址分为两部分，一部分是123.123.123.另一部分是123，又因Ip最大值为255，所以先使用分组，然后在组里边在进行选择
		 * ，组里也有三部分，0-199,200-249,250-255,分别和上述的表达是对应，最后还要注意分组之后还要加上一个.,因为是元字符所以
		 * 要转义故加上\.然后再把这部分整体看做是一个组，重复三次，再加上仅有数字的一组也就是不带上\.的那一组即可完成IP地址的校验
		 * */
		//str = "192.168.106.75"; cstr="((25[0-5]|2[0-4][0-9]|[0-1]\\d\\d)\\.){3}(25[0-5]|2[0-4][0-9]|[0-1]\\d\\d|\\d\\d)";
		
		//
		
		
		Matcher matcher = Pattern.compile(cstr).matcher(str);
		while(matcher.find()) {
			System.out.println(matcher.group(0));
		}
	}

	private static void matherMethod() {
		String str = "Hello, World! in Java.";
		Pattern pattern = Pattern.compile("W(or)(ld!)");
		Matcher matcher = pattern.matcher(str);
		while(matcher.find()) {
			System.out.println("Group 0:" + matcher.group(0));//得到第0个组--整个匹配
			System.out.println("Group 1:" + matcher.group(1));//得到第一组匹配--与(or)匹配的
			System.out.println("Group 2:" + matcher.group(2));//得到第二组匹配--与(ld!)匹配的，组也就是子表达式
			System.out.println("Start 0:" + matcher.start(0) + " End 0:" + matcher.end(0));//总匹配的索引
			System.out.println("Start 1:" + matcher.start(1) + " End 1:" + matcher.end(1));//第一组匹配的索引
			System.out.println("Start 2:" + matcher.start(2) + " End 2:" + matcher.end(2));//第二组匹配的索引
			System.out.println(str.substring(matcher.start(0), matcher.end(1)));//从总匹配开始索引到第一组匹配的结束索引之间的字符串-Wor
		}
	}
}
