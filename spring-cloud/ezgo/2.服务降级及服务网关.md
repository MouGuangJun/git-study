# 服务降级及服务网关

## 服务降级

### Hystrix断路器



![img](../../../md-photo/webp.webp)



#### 什么是服务雪崩？

> 多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的 “扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的”雪崩效应“。

> 对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。

> 所以通常当发现某个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。



#### Hystrix是干嘛的

>Hystrix是一个用于处理分布式系统的延迟和容错的一个开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能保证在一个依赖出现问题的情况下，**不会导致整体服务失败，避免级联故障，以提高分布式系统的稳定性。**

> “断路器”本身是一种开关装置，**当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的，可处理的备选响应**，而不是长时间等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。



#### 服务降级（Fallback）

>假设对方系统不可用了，向调用方返回一个符合预期的，可备选的响应。服务器忙，请稍后重试，不让客户等待并立刻返回一个友好的提示，这就是服务降级。就像if( ){ }else if{}....有备选方案。再比如给10086打电话，客服繁忙...

**出现服务降级的情况：**

- ①程序运行异常；
- ②超时；
- ③服务熔断触发服务降级；
- ④线程池/信号量打满也会导致服务降级。



##### **服务降级案例**

##### 服务端

引入pom文件：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
</dependency>
```



yml配置：

```yml
server:
  port: 8007
spring:
  application:
    name: cloud-prodiver-hystrix-payment

#eureka-client配置
eureka:
  client:
    #表示是否将自己注册进EurekaServer
    register-with-eureka: true
    #是否从EurekaServer抓取已有的注册信息，集群必须设置为true才能配合ribbon使用负载均衡
    fetch-registry: true
    service-url:
      #集群模式
      #defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/
      #单机模式
      defaultZone: http://eureka7001.com:7001/eureka/

```



编写对应的业务场景：

controller：

```java
package com.hystrix.controller;

import com.hystrix.service.PaymentService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
@Slf4j
public class PaymentController {
    @Autowired
    private PaymentService paymentService;

    @Value("${server.port}")
    private String serverPort;

    // 正常的业务场景
    @GetMapping("/payment/hystrix/ok/{id}")
    public String paymentInfo_OK(@PathVariable("id") Integer id) {
        String result = paymentService.paymentInfo_OK(id);
        log.info("-------------执行结果成功：" + result);

        return result;
    }

    // 模拟超时的业务场景
    @GetMapping("/payment/hystrix/timeOut/{id}")
    public String paymentInfo_TimeOut(@PathVariable("id") Integer id) {
        String result = paymentService.paymentInfo_TimeOut(id);
        log.info("-------------执行结果失败：" + result);

        return result;
    }

}
```



service：

```java
package com.hystrix.service;

import lombok.SneakyThrows;
import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;

@Service
public class PaymentServiceImpl implements PaymentService {
    /**
     * 正常访问的方法
     */
    @Override
    public String paymentInfo_OK(Integer id) {
        return "线程池：" + Thread.currentThread().getName() + "paymentInfo_OK, id:" + id;
    }

    /**
     * 超时的方法
     */
    @SneakyThrows
    @Override
    public String paymentInfo_TimeOut(Integer id) {
        int number = 3;
        TimeUnit.SECONDS.sleep(3);
        return "线程池：" + Thread.currentThread().getName() + "paymentInfo_TimeOut, id:" + id + ",耗时(秒)" + number + "秒钟";
    }
}

```



使用jmeter进行压力测试，访问模拟超时的服务：

![image-20220730211150205](../../../md-photo/image-20220730211150205.png)



![image-20220730211213248](../../../md-photo/image-20220730211213248.png)



发现原来正常的服务也变得缓慢了起来：

![image-20220730211256503](../../../md-photo/image-20220730211256503.png)



不难发现：<font color ='red'>**多线程并发时导致正常的服务抢占不到资源，从而也变得缓慢起来。而且上面还是服务端自测的情况，如果客户端来访问的情况下，那么客户端只能等着，而客户端不断地处理请求，导致崩溃**</font>



测试存在客户端的情况下：



##### 客户端

<font color='red'>**注意主启动类上的@EnableFeignClients注解**</font>

pom文件引入feign和erueka即可

yml配置：

```yml
server:
  port: 6004
spring:
  application:
    name: cloud-hystrix-order

# erueka
eureka:
  client:
    #表示是否将自己注册进EurekaServer
    register-with-eureka: true
    #是否从EurekaServer抓取已有的注册信息，集群必须设置为true才能配合ribbon使用负载均衡
    fetch-registry: true
    service-url:
      #单机版
      defaultZone: http://localhost:7001/eureka
      #集群版
      # defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/

# 修改OpenFeign调用远程服务的超时时间（修改Ribbon的配置）
ribbon:
  # 建立连接后从服务器读取到可用资源所用的时间
  ReadTimeout: 5000
  # 建立连接所用的时间，适用于网络正常情况下，两端连接所用的时间
  ConnectTimeout: 5000
```



controller：

```java
package com.hystrix.controller;

import com.hystrix.service.HystrixOrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HystrixOrderController {

    @Autowired
    private HystrixOrderService hystrixOrderService;

    // 正常服务
    @GetMapping("/consumer/hystrix/ok/{id}")
    public String paymentInfo_OK(@PathVariable("id") Integer id) {
        return hystrixOrderService.paymentInfo_OK(id);
    }

    // 超时服务
    @GetMapping("/consumer/hystrix/timeOut/{id}")
    public String paymentInfo_TimeOut(@PathVariable("id") Integer id) {
        return hystrixOrderService.paymentInfo_TimeOut(id);
    }
}
```



service：

```java
package com.hystrix.service;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient("CLOUD-PRODIVER-HYSTRIX-PAYMENT")
public interface HystrixOrderService {

    // 正常服务
    @GetMapping("/payment/hystrix/ok/{id}")
    String paymentInfo_OK(@PathVariable("id") Integer id);

    // 超时服务
    @GetMapping("/payment/hystrix/timeOut/{id}")
    String paymentInfo_TimeOut(@PathVariable("id") Integer id);
}

```



此时多线程访问服务端，增加到500个线程：

![image-20220730214543248](../../../md-photo/image-20220730214543248.png)



然后从服务端调用正常业务逻辑的方法：localhost:6004/consumer/hystrix/ok/1

发现<font color='red'>正常的业务运行也出现了超时的错误</font>

![image-20220730214709457](../../../md-photo/image-20220730214709457.png)





##### 服务端服务降级

<font color='red'>**使用服务降级，让客户端/服务端主动降级，以提升效率**</font>

对服务端的业务实现类进行服务降级：

```java
/**
     * 超时的方法
     * <p>
     * HystrixProperty中的属性参见{@link com.netflix.hystrix.contrib.javanica.conf.HystrixPropertiesManager}
     */
    @HystrixCommand(fallbackMethod = "paymentInfo_TimeOutHandler", commandProperties = {
            // 3秒超时后启动备用方案
            @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "3000")
    })
    @SneakyThrows
    @Override
    public String paymentInfo_TimeOut(Integer id) {
        int i = 1 / 0;
        int number = 3;
        TimeUnit.SECONDS.sleep(3);
        return "线程池：" + Thread.currentThread().getName() + "paymentInfo_TimeOut, id:" + id + ",耗时(秒)" + number + "秒钟";
    }


    // Hystrix服务降级后备选的方法
    private String paymentInfo_TimeOutHandler(Integer id) {
        return "线程池：" + Thread.currentThread().getName() + "paymentInfo_TimeOutHandler, id:" + id + ",运行错误或者超时！";
    }
```



![image-20220730231347412](../../../md-photo/image-20220730231347412.png)



添加激活服务降级注解：

![image-20220730231426265](../../../md-photo/image-20220730231426265.png)



此时在服务端访问时，如果出现了超时或者报错时，就会采用备用方案进行返回

![image-20220730231611895](../../../md-photo/image-20220730231611895.png)



##### 客户端服务降级

一般<font color='red'>**Hystrix放在客户端进行服务降级**</font>。例如服务端处理业务需要5秒钟，而客户端只愿意等3秒钟，那么此时客户端就可以采取服务降级的方案。

将服务端修改为健康的状态：

![image-20220731134121202](../../../md-photo/image-20220731134121202.png)



客户端yml添加Hystrix属性：

```yml
# 开启hystrix
feign:
  hystrix:
    enabled: true
```



主启动类添加<font color='bold'>@EnableHystrix</font>注解



修改调用支付服务的controller：

![image-20220731135346517](../../../md-photo/image-20220731135346517.png)



```java
/**
  * HystrixProperty属性 {@link com.netflix.hystrix.contrib.javanica.conf.HystrixPropertiesManager}
  */
@HystrixCommand(fallbackMethod = "paymentTimeOutFallBackMethod", commandProperties = {
    @HystrixProperty(
        name = HystrixPropertiesManager.EXECUTION_ISOLATION_THREAD_TIMEOUT_IN_MILLISECONDS,
        value = "1500")
})
// 超时服务
@GetMapping("/consumer/hystrix/timeOut/{id}")
public String paymentInfo_TimeOut(@PathVariable("id") Integer id) {
    int i = 1 / 0;
    return hystrixOrderService.paymentInfo_TimeOut(id);
}

// 降级后的方法
public String paymentTimeOutFallBackMethod(@PathVariable("id") Integer id) {
    return "支付业务繁忙或者客户端自身运行出错，请检查后再重试！";
}
```



此时从客户端访问时会发生降级：

![image-20220731135459507](../../../md-photo/image-20220731135459507.png)



##### 全局服务降级（controller）

![image-20220731141458948](../../../md-photo/image-20220731141458948.png)



```java
// 全局注解
@DefaultProperties(defaultFallback = "paymentGlobalFallbackMethod", commandProperties = {
        @HystrixProperty(
                name = HystrixPropertiesManager.EXECUTION_ISOLATION_THREAD_TIMEOUT_IN_MILLISECONDS,
                value = "2000")
})

// 正常服务
@SneakyThrows
@GetMapping("/consumer/hystrix/ok/{id}")
@HystrixCommand
public String paymentInfo_OK(@PathVariable("id") Integer id) {
    TimeUnit.SECONDS.sleep(3);
    // int i = 1 / 0;
    return hystrixOrderService.paymentInfo_OK(id);
}

// 全局处理超时/异常
public String paymentGlobalFallbackMethod() {
    return "Global全局超时/异常处理，请稍后再重试！";
}
```



得到结果：

![image-20220731141549328](../../../md-photo/image-20220731141549328.png)





##### 全局服务降级（FeignClient）

<font color='red'>**对订单调用支付系统的所有服务做降级处理，优先级大于controller的服务降级**</font>

屏蔽客户端controller对服务降级的处理：

```java
package com.hystrix.controller;

import com.hystrix.service.HystrixOrderService;
import lombok.SneakyThrows;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
/*@DefaultProperties(defaultFallback = "paymentGlobalFallbackMethod", commandProperties = {
        @HystrixProperty(
                name = HystrixPropertiesManager.EXECUTION_ISOLATION_THREAD_TIMEOUT_IN_MILLISECONDS,
                value = "2000")
})*/
public class HystrixOrderController {

    @Autowired
    private HystrixOrderService hystrixOrderService;

    // 正常服务
    @SneakyThrows
    @GetMapping("/consumer/hystrix/ok/{id}")
    /*@HystrixCommand*/
    public String paymentInfo_OK(@PathVariable("id") Integer id) {
        // TimeUnit.SECONDS.sleep(3);
        // int i = 1 / 0;
        return hystrixOrderService.paymentInfo_OK(id);
    }

    // 全局处理超时/异常
    public String paymentGlobalFallbackMethod() {
        return "Global全局超时/异常处理，请稍后再重试！";
    }


    /**
     * HystrixProperty属性 {@link com.netflix.hystrix.contrib.javanica.conf.HystrixPropertiesManager}
     */
    /*@HystrixCommand(fallbackMethod = "paymentTimeOutFallBackMethod", commandProperties = {
            @HystrixProperty(
                    name = HystrixPropertiesManager.EXECUTION_ISOLATION_THREAD_TIMEOUT_IN_MILLISECONDS,
                    value = "1500")
    })*/
    // 超时服务
    @GetMapping("/consumer/hystrix/timeOut/{id}")
    public String paymentInfo_TimeOut(@PathVariable("id") Integer id) {
        // int i = 1 / 0;
        return hystrixOrderService.paymentInfo_TimeOut(id);
    }

    // 降级后的方法
    public String paymentTimeOutFallBackMethod(@PathVariable("id") Integer id) {
        return "支付业务繁忙或者客户端自身运行出错，请检查后再重试！";
    }
}
```



新增订单调用支付系统的服务降级类

```java
package com.hystrix.service;

import org.springframework.stereotype.Component;

/**
 * 订单系统调用支付系统的所有服务降级处理
 */
@Component
public class HystrixOrderFallbackService implements HystrixOrderService {
    @Override
    public String paymentInfo_OK(Integer id) {

        return "------------HystrixOrderFallbackService fallback paymentInfo_OK";
    }

    @Override
    public String paymentInfo_TimeOut(Integer id) {
        return "------------HystrixOrderFallbackService fallback paymentInfo_TimeOut";
    }
}
```



订单调用支付模块的<font color='red'>**FeignClient上添加fallback属性**</font>

![image-20220731142848364](../../../md-photo/image-20220731142848364.png)



此时关闭支付系统（模拟服务宕机的情况），再从订单系统进行调用，可以发现客户端同样对服务降级进行了处理

![image-20220731143040109](../../../md-photo/image-20220731143040109.png)



重新启动支付服务，可以发现又可以正常调用：

![image-20220731144551201](../../../md-photo/image-20220731144551201.png)



<font color='blue'>**使用Spring切面增强处理**</font>

```java
// com.hystrix.service.HystrixOrderFallbackService 中只需要实现空方法即可
package com.hystrix.service;

import org.springframework.stereotype.Component;

/**
 * 订单系统调用支付系统的所有服务降级处理
 */
@Component
public class HystrixOrderFallbackService implements HystrixOrderService {
    @Override
    public String paymentInfo_OK(Integer id) {

        /*return "------------HystrixOrderFallbackService fallback paymentInfo_OK";*/
        return null;
    }

    @Override
    public String paymentInfo_TimeOut(Integer id) {
        /*return "------------HystrixOrderFallbackService fallback paymentInfo_TimeOut";*/
        return null;
    }
}


// 添加切面
package com.hystrix.advice;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

/**
 * 处理订单服务调用支付服务失败后的服务降级提示信息
 */
@Aspect
@Component
public class HystrixOrderAspect {
    // 配置切入点表达式
    @Pointcut("execution(* com.hystrix.service.HystrixOrderFallbackService.*(..))")
    public void pointCut() {
    }


    // 环绕通知
    @Around("pointCut()")
    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        Object result = proceedingJoinPoint.proceed();
        // 类型转换，向下转型，必定成功，因为其内部的实现MethodSignatureImpl实现的就是MethodSignature接口
        MethodSignature methodSignature = (MethodSignature) proceedingJoinPoint.getSignature();

        if (String.class.isAssignableFrom(methodSignature.getReturnType()) && result == null) {
            return String.format("[%s] fallback [%s]", proceedingJoinPoint.getTarget().getClass().getName(),
                    methodSignature.getName());
        }

        return result;
    }
}
```



此时如果发生了降级会默认返回：[类名] fallback [方法名]

![image-20220731151016758](../../../md-photo/image-20220731151016758.png)



#### 服务熔断（break）

> 类似保险丝达到最大服务访问时，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。断路器就相当于是保险丝。

> 熔断机制的描述：熔断机制是应对雪崩效应的一种微服务链路保护机制，当扇出链路某个微服务出错不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回错误信息。当检测到该节点微服务调用响应正常后，**恢复调用链路。**熔断机制通过Hystrix实现，Hystrix会监控微服务间的调用的状况，当失败的调用到一定的阈值，缺省是5秒内20次调用失败，就会启动熔断机制，熔断机制的注解是@HystrixCommand。



##### 服务熔断案例

在服务降级的服务端原有基础上进行改造

添加controller：

```java
// --------------服务熔断--------------
@GetMapping("/payment/hystrix/circuit/{id}")
public String paymentCircuitBreaker(@PathVariable("id") Integer id) {
    String result = paymentService.paymentCircuitBreaker(id);
    log.info("-------------执行结果：" + result);

    return result;
}
```



添加服务逻辑service：

```java
// 服务熔断
@HystrixCommand(fallbackMethod = "paymentCircuitBreaker_fallback", commandProperties = {
    // 是否开启断路器
    @HystrixProperty(
        name = HystrixPropertiesManager.CIRCUIT_BREAKER_ENABLED,
        value = "true"
    ),
    // 请求次数（请求总阀值）
    @HystrixProperty(
        name = HystrixPropertiesManager.CIRCUIT_BREAKER_REQUEST_VOLUME_THRESHOLD,
        value = "10"
    ),
    // 时间窗口期（快照时间窗）
    @HystrixProperty(
        name = HystrixPropertiesManager.CIRCUIT_BREAKER_SLEEP_WINDOW_IN_MILLISECONDS,
        value = "10000"
    ),
    // 失败率达到多少后跳闸（错误百分比阀值）
    @HystrixProperty(
        name = HystrixPropertiesManager.CIRCUIT_BREAKER_ERROR_THRESHOLD_PERCENTAGE,
        value = "60"
    )
})

@Override
public String paymentCircuitBreaker(Integer id) {
    if (id < 0) {
        throw new RuntimeException("-------------id不能为负数");
    }

    String serialNum = IdUtil.simpleUUID();
    return Thread.currentThread().getName() + "\t" + "调用成功，流水号：" + serialNum;
}

// 服务熔断降级后备用的方法
public String paymentCircuitBreaker_fallback(@PathVariable("id") Integer id) {
    return "id 不能为负数，请稍后再重试，id：" + id;
}
```



测试结果：

![image-20220731164356969](../../../md-photo/image-20220731164356969.png)

在多次id为负数调用的情况下，服务端触发了服务熔断，<font color ='red'>此时明明能够正常访问，不产生错误的服务（id为正数）也发生了自动降级。</font>



##### 断路器在什么情况下开始起作用？

>涉及到的三个重要参数：快照时间窗、请求总阀值、错误百分比阀值。
>
>1. 快照时间窗：断路器确定是否打开，需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。
>2. 请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20，意味着在10秒内，如果该 hystrix 命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开。
>3. 错误百分比阀值：当请求总数在快照时间窗内超过了阀值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过了50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。



##### 断路器打开之后

>1. 再有请求调用的时候，将不会调用主逻辑，而是直接调用降级 fallback。 通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。
>
>2. 原来的主逻辑要如何恢复？
>
>​	对于这一问题，Hystrix 也为我们实现了自动恢复功能。
>当断路器打开，对于主逻辑进行熔断之后，hystrix 会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑。
>​	当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果此次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。



##### 熔断机制示例图片

![img](../../../md-photo/v2-7de287b95f7c5c69401d075936f222c2_1440w.jpg)





#### 服务限流(flowlimit)

> 秒杀高并发的操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序的进行。



什么是服务限流？

我们都知道每个服务都有一个请求上限，达到该上限后，对我们服务的安全肯定会造成一些影响，比如内存溢出、请求缓慢等，因此我们应该限制服务的请求数，来保证服务的正常工作，因此<font color='red'>**Hystrix 可以根据信号量和线程池的大小进行限流降级**</font>



##### 服务限流示例

###### 通过信号量进行限流

<font color='red'>**我们把超时时间和熔断开发关了，以防止影响我们测试这部分的功能**</font>

服务端添加controller方法：

```java
@GetMapping("/payment/hystrix/flowLimitSemaphore")
public String paymentFlowLimitSemaphore() {
    return paymentService.paymentFlowLimitSemaphore();
}
```



添加业务逻辑实现service方法：

```java
// 服务限流 通过信号量限流
@SneakyThrows
@HystrixCommand(fallbackMethod = "paymentFlowLimitFallBack", commandProperties = {
        // 通过信号量进行限流
        @HystrixProperty(name = HystrixPropertiesManager.EXECUTION_ISOLATION_STRATEGY,
                value = "SEMAPHORE"),
        // 超时是否触发服务降级
        @HystrixProperty(name = HystrixPropertiesManager.EXECUTION_TIMEOUT_ENABLED,
                value = "false"),
        // 并发请求信号量达到50触发降级
        @HystrixProperty(name = HystrixPropertiesManager.EXECUTION_ISOLATION_SEMAPHORE_MAX_CONCURRENT_REQUESTS,
                value = "50"),
        // 是否允许进行服务熔断
        @HystrixProperty(name = HystrixPropertiesManager.CIRCUIT_BREAKER_ENABLED,
                value = "false"),

})
@Override
public String paymentFlowLimitSemaphore() {
    log.info("接口请求，请求次数，{}，当前时间：{} ", index.incrementAndGet(), formatter.format(LocalDateTime.now()));
    // 卡住线程，让并发量上去
    TimeUnit.SECONDS.sleep(3);

    return "请求执行成功！";
}

// 服务限流后备用的方法
public String paymentFlowLimitFallBack() {
    return "请求执行失败！";
}
```



并发100个线程进行访问：

![image-20220731220206418](../../../md-photo/image-20220731220206418.png)



可以发现信号量达到50后，触发了服务降级：

![image-20220731220305765](../../../md-photo/image-20220731220305765.png)



###### 通过并发线程数进行限流

服务端添加controller方法：

```java
// 通过线程数进行限流
@GetMapping("/payment/hystrix/flowLimitThread")
public String paymentFlowLimitThread() {
    return paymentService.paymentFlowLimitThread();
}
```



添加业务逻辑实现service方法：

```java
// 通过线程数进行限流
@HystrixCommand(fallbackMethod = "paymentFlowLimitFallBack", commandProperties = {
        // 通过线程数进行限流
        @HystrixProperty(name = HystrixPropertiesManager.EXECUTION_ISOLATION_STRATEGY,
                value = "THREAD"),
        // 超时是否触发服务降级
        @HystrixProperty(name = HystrixPropertiesManager.EXECUTION_TIMEOUT_ENABLED,
                value = "false"),
        // 是否允许进行服务熔断
        @HystrixProperty(name = HystrixPropertiesManager.CIRCUIT_BREAKER_ENABLED,
                value = "false")
}, threadPoolProperties = {

        // 设置线程池的最大队列大小，默认值 -1
        @HystrixProperty(name = HystrixPropertiesManager.MAX_QUEUE_SIZE,
                value = "10"),
        // 用来为队列设置拒绝阈值，即使队列没有到达最大值也能拒绝请求，当 maxQueueSize 属性为 -1 时候，该属性无效
        @HystrixProperty(name = HystrixPropertiesManager.QUEUE_SIZE_REJECTION_THRESHOLD,
                value = "20")
})
@SneakyThrows
@Override
public String paymentFlowLimitThread() {
    log.info("接口请求，请求次数，{}，当前时间：{} ", index.incrementAndGet(), formatter.format(LocalDateTime.now()));
    // 卡住线程，让并发量上去
    TimeUnit.SECONDS.sleep(3);

    return "请求执行成功！";
}

// 服务限流后备用的方法
public String paymentFlowLimitFallBack() {
    return "请求执行失败！";
}
```



并发100个线程进行访问：

![image-20220731220627963](../../../md-photo/image-20220731220627963.png)



可以发现线程数达到20后，触发了服务降级：

![image-20220731221413666](../../../md-photo/image-20220731221413666.png)



#### 图形化界面(Hystrix Dashboard)

##### 什么是Hystrix Dashboard?

  Hystrix Dashboard是Spring Cloud的<font color='red'>仪表盘组件</font>，可以查看Hystrix实例的执行情况，支持查看单个实例和查看集群实例，但是需要结合spring-boot-actuator一起使用。
  Hystrix Dashboard主要用来实时监控Hystrix的各项指标信息。<font color='red'>Hystrix Dashboard可以有效地反映出每个Hystrix实例的运行情况</font>，帮助我们快速发现系统中的问题，从而采取对应措施。
  Hystrix的主要优点之一是它收集的有关每个HystrixCommand的一组指标。<font color='red'>Hystrix仪表板以有效的方式显示每个断路器的运行状况</font>。



##### 监控实例

添加Hystrix图形化监控项目

yml只需标注端口号即可

引入依赖：

```xml
<dependencies>
    <!-- hystrix 监控仪表盘-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>
    </dependency>

    <!--lombok-->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>

    <!--devtools-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>
    
    <!--spring-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```



建主启动类并且添加激活hystrix-dashboard注解：<font color='bold'>@EnableHystrixDashboard</font>

```java
package com.hystrix.dashboard;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;

@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
@EnableHystrixDashboard
public class DashBoardApplication9002 {
    public static void main(String[] args) {
        SpringApplication.run(DashBoardApplication9002.class, args);
    }
}

```



启动程序并访问地址：[Hystrix Dashboard](http://localhost:9002/hystrix)



被监控的服务需要添加spring-boot-starter-actuator依赖：

![image-20220731174935844](../../../md-photo/image-20220731174935844.png)



被监控的服务端添加监控默认路径：

![image-20220731181249630](../../../md-photo/image-20220731181249630.png)

```java
/**
 * 而配置服务监控默认路径
 */
@Bean
public ServletRegistrationBean getRegistrationBean() {
    ServletRegistrationBean registrationBean = new ServletRegistrationBean(
            new HystrixMetricsStreamServlet());
    registrationBean.setLoadOnStartup(1);
    registrationBean.addUrlMappings("/hystrix.stream");
    registrationBean.setName("HystrixMetricsStreamServlet");

    return registrationBean;
}
```



在Hystrix Dashboard的前端地址对服务端进行监控：

![image-20220731181348331](../../../md-photo/image-20220731181348331.png)

##### 监控详情

![img](../../../md-photo/webp.webp)





![img](../../../md-photo/webp-16592627128953.webp)



![img](../../../md-photo/webp-16592627252306.webp)



![img](../../../md-photo/webp-16592627591049.webp)



#### Hystrix常用配置

```yml
# Hystrix
hystrix:
  command:
    default:
      execution:
        timeout:
          enabled: true #是否应该有超时
        isolation: # 隔离策略
          #隔离策略，有THREAD 、SEMAPHORE,
          #THREAD - 它在单独的线程上执行，并发请求受线程池中的线程数量的限制
          #SEMAPHORE - 它在调用线程上执行，并发请求受到信号量计数的限制
          strategy: THREAD
          semaphore:  #信号量
            maxConcurrentRequests: 100  #配置信号量的大小，当最大并发请求数达到该设置值，后续的请求将会被拒绝
          thread:
            timeoutInMilliseconds: 30000 #服务调用超时时间,THREAD隔离模式下是请求超时是会取消调用线程从而立即返回的，SEMAPHORE模式下会等待响应回来再判断是否超时。
            interruptOnTimeout: true   #执行超时的时候，是否需要将他中断
            interruptOnCancel: true  #是否在方法执行被取消时中断方法
      fallback: # 服务降级策略
        enabled: true  #服务降级策略是否启用,默认值 true ，如果设置为false，当请求失败或拒绝发生时，将不会调用 HystrixCommand.getFallback() 来执行服务降级逻辑
        isolation:
          semaphore:
            maxConcurrentRequests: 10000  # 设置从调用线程中允许HystrixCommand.getFallback()方法执行的最大并发请求数。当达到最大并发请求时，后续的请求将会被拒绝并抛出异常。
      circuitBreaker: #服务熔断策略
        enabled: true  #确定当服务请求命令失败时，是否使用断路器来跟踪其健康指标和熔断请求，默认值 true
        requestVolumeThreshold: 10 #用来设置在滚动时间窗中，断路器的最小请求数。例如：默认值 20 的情况下，如果滚动时间窗（默认值 10秒）内仅收到19个请求，即使这19个请求都失败了，断路器也不会打开。
        errorThresholdPercentage: 80 #用来设置断路器打开的错误百分比条件。例如，默认值为 50 的情况下，表示在滚动时间窗中，在请求数量超过 circuitBreaker.requestVolumeThreshold 阈值的请求下，如果错误请求数的百分比超过50，就把断路器设置为"打开"状态，否则就设置为"关闭"状态。
        sleepWindowInMilliseconds: 5000 #用来设置当断路器打开之后的休眠时间窗。默认值 5000 毫秒，休眠时间窗结束之后，会将断路器设置为"半开"状态，尝试熔断的请求命令，如果依然失败就将断路器继续设置为"打开"状态，如果成功就设置为"关闭"状态。
      metrics: #统计器
        rollingStats: #滚动时间窗口
          timeInMilliseconds: 10000 #用于设置滚动时间窗的长度，单位毫秒，该时间用于断路器判断健康度时需要收集信息的持续时间，默认值 10000 。断路器值啊收集指标信息时候会根据设置的时间窗长度拆分成多个"桶"来累计各度量值，每个"桶"记录了一段时间内的采集指标。
          numBuckets: 10 #用来设置滚动时间窗统计指标信息时，划分"桶"的数量，默认值 10 。 metrics.rollingStats.timeInMilliseconds 参数的设置必须能被该参数整除，否则将抛出异常。
        rollingPercentile: #百分位数
          enabled: true #用来设置对命令执行的延迟是否使用百分位数来跟踪和计算，默认值 true ，如果设置为 false 那么所有概要统计都将返回 -1
          timeInMilliseconds: 60000 #用来设置百分位统计的滚动窗口的持续时间，单位：毫秒，默认值 60000
          numBuckets: 6 # 用来设置百分位统计窗口中使用"桶"的数量，默认值 6
          bucketSize: 100 #用来设置在执行过程中每个"桶"中保留的最大执行次数，如果在滚动时间窗内发生超该设定值的执行次数，就从最初的位置开始重写，例如：设置为 100，滚动窗口为 10 秒，若在10秒内一个"桶"中发生了500次执行，那么该"桶"中只保留最后的100次执行的统计，默认值 100
        healthSnapshot:
          intervalInMilliseconds: 500 # 用来设置采集影响断路器状态的健康快照（请求的成功、错误百分比）的间隔等待时间,默认值 500
    requestCache:
      enabled: false  #是否开启请求缓存
    requestLog:
      enabledg: true #用来设置 HystrixCommand 的执行和事件是否打印日志到 HystrixRequestLog 中，默认值 true
    #自己的key
    userGetKey:
      execution:
        timeout:
          enabled: false #是否应该有超时
        isolation:
          #隔离策略，有THREAD 、SEMAPHORE,
          #THREAD - 它在单独的线程上执行，并发请求受线程池中的线程数量的限制
          #SEMAPHORE - 它在调用线程上执行，并发请求受到信号量计数的限制
          strategy: SEMAPHORE
          thread:
            timeoutInMilliseconds: 2000 #服务调用超时时间
            interruptOnTimeout: true
  threadpool: #线程池策略
    default:
      coreSize: 100 #设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量，默认值 10
      allowMaximumSizeToDivergeFromCoreSize: true #是否允许线程池扩展到最大线程池数量，默认为 false;
      maximumSize: 1000 #线程池中线程的最大数量，默认值是 10，此配置项单独配置时并不会生效，需要启用 allowMaximumSizeToDivergeFromCoreSize 项。
      maxQueueSize: 8000 #设置线程池的最大队列大小，当设置为 -1 时，线程池将使用 SynchronousQueue 实现的队列，否则使用 LinkedBlockingQueue 实现的队列，默认值 -1
      queueSizeRejectionThreshold : 8000 #用来为队列设置拒绝阈值，即使队列没有到达最大值也能拒绝请求，该属性主要对 LinkedBlockingQueue 队列的补充，默认值 5，当 maxQueueSize 属性为 -1 时候，该属性无效
      keepAliveTimeMinutes: 2 #等到线程池空闲后，多于核心数量的线程还会被回收，此值指定了线程被回收前的存活时间，默认为 2，即两分钟。
      metrics:
        rollingPercentile:
          timeInMilliseconds: 10000  #用来设置线程池统计的滚动窗口的持续时间，单位：毫秒，默认值 10000
          numBuckets: 10 #用来设置线程池统计窗口中使用"桶"的数量，默认值 10
  collapser:
    default:
      maxRequestsInBatch: 100 # 用来设置一次请求合并批处理允许的最大请求数量，默认值 Integer.MAX_VALUE
      timerDelayInMilliseconds: 10 #用来设置批处理过程中每个命令延迟的时间，单位毫秒，默认值 10
      requestCache:
        enabled: true #用来设置批处理过程中是否开启请求缓存，默认值 true
```





## 服务网关

### Spring Cloud Gateway

**Spring Cloud Gateway 的核心就是一系列的过滤器，可以将客户端的请求转到不同的服务器，即可简要的称为过滤和路由。**

![image](../../../md-photo/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1ZXNoYW5mZWl0aWFu,size_16,color_FFFFFF,t_70.png)



**SpringCloud Gateway核心功能**

- **路由（route）** 路由信息的组成：由一个ID、一个目的URL、一组断言工厂、一组Filter组成。如果路由断言为真，说明请求URL和配置路由匹配。
- **断言（Predicate）** Spring Cloud Gateway中的断言函数输入类型是Spring 5.0框架中的ServerWebExchange。Spring Cloud Gateway的断言函数允许开发者去定义匹配来自于Http Request中的任何信息比如请求头和参数。
- **过滤器（Filter）** 一个标准的Spring WebFilter。 Spring Cloud Gateway中的Filter分为两种类型的Filter，分别是Gateway Filter和Global Filter。过滤器Filter将会对请求和响应进行修改处理。



具体的逻辑处理顺序如下图所示：

![image](../../../md-photo/20210601103041489.png)

1. 客户端向 Spring Cloud Gateway 发出请求。
2. 在 Gateway Handler Mapping 中找到与请求相匹配的路由。
3. 将其发送到 Gateway Web Handler。
4. Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑。
5. 然后返回，返回时可以对响应信息进行修改。



### 搭建实例

新建项目

引入依赖：

```xml
<!--引入spring cloud gateway网关-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>

<!-- gateway同样需要作为客户端注册到eureka注册中心 -->
<!--eureka-client-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>

<!-- 其他Spring的依赖暂时忽略 -->
```



yml：

```yml
server:
  port: 1001

spring:
  application:
    name: spring-cloud-gateway

eureka:
  client:
    #表示是否将自己注册进EurekaServer
    register-with-eureka: true
    #是否从EurekaServer抓取已有的注册信息，集群必须设置为true才能配合ribbon使用负载均衡
    fetch-registry: true
    service-url:
      #单机版
      defaultZone: http://localhost:7001/eureka
      #集群版
      # defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/
  instance:
    hostname: spring-cloud-gateway-service
```



添加主启动类：

```java
package com.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
@EnableEurekaClient
public class GatewayApplication1001 {
    public static void main(String[] args) {
        SpringApplication.run(GatewayApplication1001.class, args);
    }
}
```



在<font color='green'>rodiver-payment-8001</font>项目中添加两个测试的服务

```java
package com.payment.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 添加对GatWay网关测试的Controller
 */
@RestController
public class GateWayController {

    @Value("${server.port}")
    private String serverPort;
    
    @GetMapping("/gateway/getServer1")
    public String getServerPort1() {
        return serverPort + "1";
    }

    @GetMapping("/gateway/getServer2")
    public String getServerPort2() {
        return serverPort + "2";
    }
}
```



在Spring Cloud Gateway的yml文件中添加对上述两个服务请求地址的<font color='red'>路由断言</font>和<font color='red'>路由过滤</font>

```yml
spring:
  #gateway网关配置
  cloud:
    gateway:
      routes:
        - id: getServerPort1 #路由的id，没有固定的规则但是要求唯一，建议配合服务名
          uri: http://localhost:8001 #匹配后提供服务的路由地址
          predicates:
            - Path=/gateway/getServer1/** # 断言，路径相匹配的进行路由

        - id: getServerPort2
          uri: http://localhost:8001
          predicates:
            - Path=/gateway/getServer2/**
```



启动网关服务，发生以下错误：

![image-20220731234141346](../../../md-photo/image-20220731234141346.png)



移除spring-boot-starter-web依赖即可：

![image-20220731234630640](../../../md-photo/image-20220731234630640.png)



启动程序后发现，无论是使用真实的地址进行访问，还是Spring Cloud Gateway的地址进行访问，都可以成功的访问到服务的相关信息

![image-20220731235128805](../../../md-photo/image-20220731235128805.png)



![image-20220731235151867](../../../md-photo/image-20220731235151867.png)



### GateWay配置方式

#### yml配置

见上述案例 <font color='red'>**(建议使用)**</font>



#### Java代码中进行配置

添加GateWay的配置文件即可

```java
package com.gateway.config;

import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GateWayConfig {

    @Bean
    public RouteLocator newsGuoNei(RouteLocatorBuilder routeLocatorBuilder) {
        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();

        // 其中[*]表示该属性为数组
        // 第一个参数 = spring.cloud.gateway.routes[id]
        // path = spring.cloud.gateway.routes[predicates][Path]
        // uri = spring.cloud.gateway.routes[uri]
        // 此时访问：http://localhost:1001/guonei，会自动跳转到http://news.baidu.com/guonei
        // 相当于使用了Spring Cloud GateWay进行了一次转发
        return routes.route("path_route_guoji", builder -> builder.path("/guonei")
                .uri("http://news.baidu.com/guonei")).build();
    }


    // 需要配置多个路由的情况
    @Bean
    public RouteLocator newsGuoJi(RouteLocatorBuilder routeLocatorBuilder) {
        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();

        // 此时访问：http://localhost:1001/guoji，会自动跳转到http://news.baidu.com/guoji
        return routes.route("path_route_guoji", builder -> builder.path("/guoji")
                .uri("http://news.baidu.com/guoji")).build();
    }
}

```

<font color='red'>**如果存在多个路由配置，只需要在后面继续添加对应的路由Bean即可**</font>



### 通过微服务名实现动态路由

修改gateway网关配置：

添加spring.cloud.gateway.discovery.locator.enabled=true

将spring.cloud.gateway.routes[uri]修改为lb://cloud-payment-service

```yml
spring:
  #gateway网关配置
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名进行注册
      routes:
        - id: getServerPort1 #路由的id，没有固定的规则但是要求唯一，建议配合服务名
          # uri: http://localhost:8001 #匹配后提供服务的路由地址
          uri: lb://cloud-payment-service #匹配后提供服务的路由地址
          predicates:
            - Path=/gateway/getServer1/** # 断言，路径相匹配的进行路由

        - id: getServerPort2
          # uri: http://localhost:8001
          uri: lb://cloud-payment-service #匹配后提供服务的路由地址
          predicates:
            - Path=/gateway/getServer2/**
```



测试时需要8001和8002提供服务

![image-20220801222134143](../../../md-photo/image-20220801222134143.png)



可以发现已经实现了负载均衡

由8001服务器提供服务：

![image-20220801222203379](../../../md-photo/image-20220801222203379.png)



由8002服务器提供服务：

![image-20220801222211579](../../../md-photo/image-20220801222211579.png)



### Predicate使用

#### After

```properties
# 在2022/08/01 23:52:20.517之后开始生效
- After=2022-08-01T23:52:20.517+08:00[Asia/Shanghai]
```

![image-20220801230045168](../../../md-photo/image-20220801230045168.png)



<font color='green'>获取带时区的时间</font>

```java
ZonedDateTime now = ZonedDateTime.now();
System.out.println(now);
```



#### Before

同After

```properties
# 在2022/08/01 23:52:20.517之前开始生效
- Before=2022-08-01T23:52:20.517+08:00[Asia/Shanghai]
```



#### between

同After

```properties
# 在2022/08/01 22:52:20.517之后2022/08/01 23:52:20.517之前生效
- Between=2022-08-01T22:52:20.517+08:00[Asia/Shanghai],2022-08-01T23:52:20.517+08:00[Asia/Shanghai]
```



#### Cookie

```properties
# username -> cookie名称，zzzq -> 正则表达式
# 通过Cookie name和正则表达式去匹配，如果匹配上则执行，否则不执行
- Cookie=username,zzzq
```



使用<font color='red'>**curl命令**</font>进行测试

不带Cookie进行访问直接报错：

curl http://localhost:1001/gateway/getServer2

![image-20220801232129411](../../../md-photo/image-20220801232129411.png)



带Cookie访问成功：

curl http://localhost:1001/gateway/getServer2 --cookie "username=zzzq"

![image-20220801232040340](../../../md-photo/image-20220801232040340.png)



#### Header

```properties
# X-Request-Id -> 属性名称，\d+ -> 正则表达式
# 通过属性名称和正则表达式去匹配，如果匹配上则执行，否则不执行
# 请求头要有X-Request-Id属性并且值为正数的正则表达式
- Header=X-Request-Id,\d+
```



X-Request-Id的值为正数访问成功：

curl http://localhost:1001/gateway/getServer2 -H "X-Request-Id:123"

![image-20220801232646282](../../../md-photo/image-20220801232646282.png)



X-Request-Id的值为负数访问成功：

curl http://localhost:1001/gateway/getServer2 -H "X-Request-Id:-123"

![image-20220801232731994](../../../md-photo/image-20220801232731994.png)



#### Host

```properties
# 接收一组匹配域名的列表，用.号作为分隔符。它通过参数中的主机地址作为匹配规则
- Host=**.gateway.com
```

正确匹配的主机名称访问成功：

curl http://localhost:1001/gateway/getServer2 -H "Host:com.gateway.com"

![image-20220801233220488](../../../md-photo/image-20220801233220488.png)



错误的匹配的主机名称访问失败：

curl http://localhost:1001/gateway/getServer2 -H "Host:com.gateway.com.cn"

![image-20220801233243689](../../../md-photo/image-20220801233243689.png)



#### Method

```properties
# 只能通过GET方式进行请求
- Method=GET
```

通过Post方法进行请求失败：

![image-20220801233430221](../../../md-photo/image-20220801233430221.png)



#### Path

```properties
# 通过路径进行匹配，不再多说
- Path=/gateway/getServer2/**
```



#### Query

```properties
# username -> 参数名，\d+ -> 属性值的正则表达式
# 要有参数username，并且值为正数才能路由
- Query=username,\d+
```



使用正确的参数名、参数值访问成功

curl http://localhost:1001/gateway/getServer2?username=12

![image-20220801234031976](../../../md-photo/image-20220801234031976.png)



使用错误的参数名、参数值访问失败

curl http://localhost:1001/gateway/getServer2?username=-12

![image-20220801234103926](../../../md-photo/image-20220801234103926.png)



更多参照官网链接：

所有的工厂都实现了<font color ='red'>org.springframework.cloud.gateway.support.Configurable</font>接口，可以通过IDEA构件图来进行相应的查看。

[Spring Cloud Gateway](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories)

![image-20220801223220145](../../../md-photo/image-20220801223220145.png)



### Filter使用

#### 配置类过滤器（单一）

添加filter：

```yml
filters:
  # 网关外访问路径为/redundant/gateway/getServer1/**，但是经过网关后会去除第一个路径
  # 变为/gateway/getServer1/**
  # 1代表去除一个路径
  - StripPrefix=1
```



![image-20220801235218699](../../../md-photo/image-20220801235218699.png)



前端访问地址：localhost:1001/redundant/gateway/getServer1

![image-20220801235421312](../../../md-photo/image-20220801235421312.png)



其他的配置参见：[Spring Cloud Gateway](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories)

![image-20220801235809650](../../../md-photo/image-20220801235809650.png)



#### 配置类过滤器（全局）

忽略



#### 自定义过滤器

主要应用场景：<font color='red'>**全局日志记录、统一网关鉴权**</font>

实现两个接口org.springframework.cloud.gateway.filter.GlobalFilter（对请求体进行判断），org.springframework.core.Ordered（排序接口，值越小越先执行）

添加自定义的过滤器：

![image-20220802223418872](../../../md-photo/image-20220802223418872.png)



源代码：

```java
package com.gateway.filter;

import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.util.Date;

/**
 * 自定义的全局网关过滤器
 */
@Component
@Slf4j
public class MyGlobalFilter implements GlobalFilter, Ordered {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        log.info("---------------进入自定义的全局过滤器开始......" + new Date());
        // 获取请求中的第一个参数
        String userName = exchange.getRequest().getQueryParams().getFirst("userName");
        if (userName == null) {
            log.info("---------------用户名为null，非法用户---------------");
            // 400，非法的参数
            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);
            // 放行操作
            return exchange.getResponse().setComplete();
        }


        // 放行
        return chain.filter(exchange);
    }

    @Override
    public int getOrder() {
        return 0;
    }
}
```



此时从外部访问，如果请求参数中带有userName才能访问成功

无参数，访问失败：

[localhost](http://localhost:1001/redundant/gateway/getServer1)

![image-20220802223826729](../../../md-photo/image-20220802223826729.png)



有参数，访问成功：

[localhost:1001/redundant/gateway/getServer1?userName=zhangsan](http://localhost:1001/redundant/gateway/getServer1?userName=zhangsan)

![image-20220802223759568](../../../md-photo/image-20220802223759568.png)

